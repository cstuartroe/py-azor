from typing import List
from src.ast import Declaration, Expression


C_TOP_COMMENT = """
// This file was autogenerated by the Azor compiler
// Check out https://github.com/cstuartroe/py-azor for more information!

"""


CMAIN = """\
int main() {{
\tprintf("%d\\n", {});
}}
"""

C_IPOW = """\
int __ipow(int base, int exp) {
\treturn ((exp == 0) ? 1 : (((exp % 2) == 0) ? __ipow((base * base), (exp / 2)) : (base * __ipow(base, (exp - 1)))));
}\n
"""

C_BINOPS = {
    "&": "&&",
    "|": "||",
    "^": "!=",
    "!^": "==",
}


class Compiler:
    def __init__(self, stmts: List[Declaration]):
        self.stmts = stmts
        self.define_exponentiation = False

    def compile(self, outfile):
        c_statements: List[str] = []

        main = None

        for stmt in self.stmts:
            if stmt.label.s == "main":
                main = stmt

            else:
                c_statements.append(
                    self.compile_declaration(stmt),
                )

        c_statements.append(
            self.compile_main(main),
        )

        with open(outfile, "w") as fh:
            fh.write("#include <stdio.h>\n")
            fh.write("#include <stdbool.h>\n")
            fh.write(C_TOP_COMMENT)

            if self.define_exponentiation:
                fh.write(C_IPOW)

            for c_statement in c_statements:
                fh.write(c_statement)

    def compile_main(self, main: Declaration):
        return CMAIN.format(self.compile_expression(main.rhs))

    def compile_declaration(self, stmt: Declaration):
        if stmt.typehint.args is None:
            return self.compile_constant_declaration(stmt)
        else:
            return self.compile_function_declaration(stmt)

    def compile_constant_declaration(self, stmt: Declaration):
        return f"const {stmt.typehint.simpletype.__name__} {stmt.label.s} = {self.compile_expression(stmt.rhs)};\n\n"

    def compile_function_declaration(self, stmt: Declaration):
        argstrings = [f"{atype.simpletype.__name__} {aname}" for aname, atype in stmt.typehint.args]

        return f"{stmt.typehint.simpletype.__name__} {stmt.label.s}({', '.join(argstrings)}) {{\n" \
               f"\treturn {self.compile_expression(stmt.rhs)};\n" \
               f"}}\n\n"

    def compile_expression(self, expr: Expression):
        if expr.expr_type == "SIMPLE":
            return expr.token.s

        elif expr.expr_type == "CALL":
            return f"{expr.left}({', '.join(map(self.compile_expression, expr.args))})"

        elif expr.expr_type == "IF":
            return f"({self.compile_expression(expr.condition)} ? {self.compile_expression(expr.left)} " \
                   f": {self.compile_expression(expr.right)})"

        elif expr.expr_type == "BINOP":
            if expr.token.s == "**":
                self.define_exponentiation = True

                return f"__ipow({self.compile_expression(expr.left)}, {self.compile_expression(expr.right)})"

            else:
                return f"({self.compile_expression(expr.left)} {C_BINOPS.get(expr.token.s, expr.token.s)} " \
                       f"{self.compile_expression(expr.right)})"

        elif expr.expr_type == "PREFIX":
            return f"({expr.token.s}{self.compile_expression(expr.right)})"

        else:
            raise ValueError("Unknown expression type: " + expr.expr_type)
